# Node 공부

----------

아래 내용은 Node에 대해 핵심적으로 알아야 할 내용들을 찾아 공부하며, 이해한 내용을 최대한 자세하고 정확하게 가공하여 적은 것들이다. 

**Node?**

> 공식 홈페이지에서는 노드를 **크롬 V8 자바스크립트 엔진으로 빌드된 JS 런타임**이라고 정의하고 있다. 간단하게 말하면 노드는 **JS** **실행기**이다. 그럼 노드가 없었을 때는 JS를 실행하지 못했을까? 원래 JS는 HTML 파일 안에서 스크립트 태그로 포함되고 브라우저에서 실행되어 왔다. 즉, **초기의 JS는 브라우저와 HTML에 종속되어 능동적으로 무언가를 하는 데 많은 제약**이 있었다. 그런데 Node가 개발되고 JS는 그러한 종속성으로부터 완전히 해방된다. 이것과 더불어 크롬이 나오고 JS 코드를 빠르게 실행시킬 수 있게 되면서 특히 웹 개발을 하는 실무에서 많은 지지를 받는다. 
>
> 개발자 비중에서 웹 개발자가 가장 많은데, 웹 개발자는 프론트엔드에 쓰이는 언어가 JS뿐이라서 JS를 당연히 다룰 수밖에 없다. 이 말은 곧 JS 개발자가 가장 많다는 말과 같다. 사람은 기본적으로 귀찮음을 느끼기 때문에 ‘한 언어로 모든 것을 할 수 없을까?’라는 생각을 한다. 이러한 생각을 현실로 만들어주는 것이 바로 Node이다. 
>
> Node를 잘 모르는 사람들은 Node를 서버라고 생각한다. 그것은 틀린 말이고 단지 서버를 생성하고 실행하고 처리를 하도록 코딩되어 있는 JS코드를 실행시켜주는 일을 하는 것일 뿐이다. 
>
> 노드는 C++로 구현된 V8과 libuv를 내부적으로 포함하고 있다. V8은 오픈 소스 JS 엔진이며 JS의 속도 문제를 개선해준다. 또한 libuv는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현한 라이브러리인데, 이 libuv로 인해 비동기 I/O 처리가 가능하게 됐다. JS는 싱글 스레드와 비동기 I/O 모델을 택하였고 프로그래밍 난이도도 Java처럼 멀티 스레드를 구현하는 것만큼 어렵지 않고 쉽고 처리 속도도 엄청나게 빠르다. 그래서 Node가 초보자가 입문하기에도 비교적 편한 장점이 있다. 



**Node의 특성?**

> 1. **이벤트 기반**: 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식.
>
>    어떤 이벤트에 연관된 이벤트 리스너에 콜백함수를 등록해두고 그 이벤트가 발생하면 이벤트 리스너가 감지하여 해당 이벤트 처리를 위해 콜백 함수를 호출하게 된다.
>
>    그냥 너무 당연한 이야기를 하는 것이기 때문에 어렵게 받아드리지 않아도 되는 것이다. Node만 그런 것이 아니라 대부분 갖는 특성이다. 기본적인 특성이라고 보면 된다.
>
> 2. **논 블로킹**: 오래 걸리는 작업(I/O작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등)을 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 작업을 실행. 반면 그런 작업이 아닌 경우에는 블로킹 방식으로 실행된다. 논 블로킹과 함께 다니는 용어는 비동기이다. 
>
> 3. **싱글 스레드**: 노드 프로세스는 멀티 스레드로 이루어져 있지만 사람이 컨트롤 할 수 있는 스레드는 하나이기 때문에 싱글 스레드라고 표현. 주로 멀티 스레드 대신 멀티 프로세스 활용(I/O 작업이 많을 때). 14버전부터 멀티 스레드 사용이 가능해졌다.
>
>    싱글 스레드이기 때문에 동시성이 없다. 프로그램 기능 및 효율면에서 멀티 스레드로 되어 있는 것이 동시성을 갖기에 사용자에게 있어 무조건 좋지만 개발하는 사람의 입장에서 멀티 스레드를 개발하는 일은 매우 힘든 일(빡쌘 코딩)이다. 그래서 Node에서는 그냥 싱글 스레드를 택하여 프로그램이 한 번에 한 가지 일에 집중하도록 하며 개발자의 부담을 줄여줬다. 그래도 안 하는 것과 못하는 것은 다른데, Node는 멀티 스레딩을 못했지만 14버전 부터는 멀티 스레드를 다룰 수 있게 기능을 확장시켰다. 그냥 없어서 아쉬우니 추가된 기능일 뿐 배워서 써먹을 일은 없다. 



**Node의 역할?**

>  **서버의 역할을 할 수 있는 Node의 장단점**
>
>  ![K-001](https://user-images.githubusercontent.com/52457180/90981680-6aa44c80-e59d-11ea-819f-08dcdbc757aa.jpg)
>
>  - CPU 작업을 위해 AWS Lambda나 Google Cloud Functions 같은 별도 서비스를 사용한다. Node는 JS 런타임이기 때문에 용도가 서버에만 한정되지 않고 웹, 모바일, 데스크탑 애플리케이션에 모두 사용될 수 있다. 



- [x] 중간메모
  - 동기를 이해하려면 실행 컨텍스트(호출 스택, this, scope)를 알아야 하고, 비동기를 이해하기 위해서는 이벤트 루프를 알아야 한다.
  - 자바스크립트에서 가장 중요한 이론적인 개념은 실행 컨텍스트, 이벤트 루프, 프로토타입이다.



**호출 스택? 백그라운드? 태스크 큐? 이벤트 루프**

> ![K-002](https://user-images.githubusercontent.com/52457180/90985100-90891b80-e5b4-11ea-8244-2eebce233344.jpg)
>
> 자바스크립트로 만들어진 프로그램이 실행되면서 **V8 엔진의 호출 스택**에는 가장 아래에 기본적으로 anonymous라는 가상의 전역 컨텍스트가 쌓인다. 그 위에 **동기적**(위에서 아래로 순서대로)으로 호출된 순서대로 함수가 쌓이고 함수가 끝나면서 빠지게 된다. 만약 함수가 끝나기 전에 그 안에서 또 다른 함수를 호출한다면 호출 스택에 처음 호출한 함수 위에 새로 부른 함수가 쌓이며 늦게 호출한 함수가 끝나야 일찍 호출한 함수가 스택에서 빠져나올 수 있다.
>
> 자바스크립트에서 비동기적으로 일을 처리할 수 있도록 만들어 놓은 함수(대표적으로 setTimeout())들이 있는데, 그러한 함수들은 브라우저나 NodeJS(**JS 구동 환경**)에게 web apis의 이벤트(타이머)를 요청한 후 바로 스택에서 제거된다.(이 과정에서 소스코드 끝이면서 스택 가장 아래에 anonymous만 있다면 anonymous도 빠져나와 빈 상태가 됨.) 그러한 구동 환경에 의해 백그라운드에서 요청했었던 특정 비동기 api(타이머)의 작업이 완료되면 등록시켰던 콜백 함수를 **태스크 큐**(콜백 함수들이 대기하는 큐(FIFO) 형태의 배열)에 추가시켜 대기시킨다.
>
> 대기하고 있던 콜백 함수들은 호출 스택이 완전히 빈 상태가 될 때 까지 대기를 한다. 빈 상태가 되면 그제서야 **이벤트 루프**에 의해 호출 스택으로 옮겨져(태스크 큐에서 대기 중이던 우선 순위가 높은 것이 먼저 빠져 나간다. 예를 들면 promise) 동기적으로 일이 처리된다. 
>
> 이런 식으로 이벤트 루프는 '**현재 실행중인 태스크가 없는지**'와 '**태스크 큐에 태스크가 있는지**'를 반복적으로 확인하는 것
>
> ```javascript
> function oneMore() {
>     console.log("one more");
> }
> function run(){
>     console.log("run run");
>     setTimeout(() => {
>         console.log("wow");
>     }, 0);
>     new Promise((resolve) => {
>         resolve("hi");
>     }).then(console.log);
>     oneMore();
> }
> setTimeout(run, 5000);
> ```
>
> ```
> 실행결과:
> run run
> one more
> hi
> wow
> ```



- [x] 중간메모**(중요)**
  - Promise에서 then 전은 호출 스택에서 동기적으로 처리되고 then 이후는 백그라운드로 넘어가 비동기적으로 작업을 처리한다.
  - 백그라운드에서 동시에 실행된다고 했는데, 어? 자바스크립트는 싱글 스레드인데 무슨 말이지? 하고 의문이 생길 수 있다. 실제로 V8과 같은 자바스크립트 엔진은 단일 호출 스택(Call Stack)을 사용하며, 요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리할 뿐이다. 그렇다면 비동기 요청은 어떻게 이루어지며, 동시성에 대한 처리는 누가 하는 걸까? 바로 이 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 Node.js가 담당한다.
  - 백그라운드(Web APIs)와 태스크 큐는 다른 언어(C++)로 구현되어 있다. 노드의 구성 요소인 libuv가 백그라운드나 태스크 큐에서의 일처리를 할 수 있도록 지원한다. 따라서, 싱글 스레드의 특성을 갖는 Node의 특성을 어기는 것이 아니라 다른 언어로 만들어진 것들에 의해 마치 멀티 스레드인 것처럼 동작한다. 그래서 동시성을 갖는 것처럼 보이고 JS 자체에는 동시성이 없다. 이런 동시성과 밀접한 개념이며 용어인 이벤트 루프를 이해해야 한다. 자바스크립트는 이 이벤트 루프를 이용해 비동기 방식으로 동시성을 지원한다. 
  - libuv가 바로 이벤트 루프를 제공한다고 보면 된다. 정리하면, V8은 비동기 작업을 위해 Node.js의 API를 호출하며, 이 때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.
  - 자바스크립트가 '단일 스레드' 기반의 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 '이벤트 루프'인 것이다.
  - 전역 환경에서 실행되는 코드는 한 단위의 코드블록으로써 가상의 익명함수로 감싸져 있다고 생각하는 것이 좋다. 따라서 위의 코드의 첫 줄이 실행될 때에 호출 스택의 맨 아래에 익명 함수가 하나 추가되며, 마지막 라인까지 실행되고 나서야 스택에서 제거된다.
  - `setTimeout` 뿐만 아니라 브라우저의 다른 비동기 함수들(`addEventListener`, `XMLHttpRequest`… )이나 Node.js의 IO 관련 함수들 등 모든 비동기 방식의 API들은 이벤트 루프를 통해 콜백 함수를 실행한다.
  - Node.js의 비동기 API들은 **중첩된 콜백 호출에 대한 에러 처리**를 위해 '**첫 번째 인수는 에러 콜백 함수**' 라는 컨벤션을 따르고 있다
  - 아까 Promise의 then은 우선 순위가 높아 먼저 실행된다고 했는데, 좀 더 자세하게 말해보면 promise에 의한 콜백 함수는 일반 태스크 큐에 추가되지 않고 별도의 **마이크로 태스크 큐**에 추가된다. 그리고 이벤트 루프는 코드의 실행이 끝나면 가장 먼저 마이크로 태스크 큐가 비어있는지 확인 후 있다면 호출 스택으로 옮겨 먼저 실행시키고 나중에 다 빈 것을 확인 한 후에 일반 태스크 큐에 있는 것을 호출 스택으로 옮겨 실행시킨다. 



